## 사용자 Entity

```java
@Entity
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {
    @Id
    @GeneratedValue (strategy = GenerationType.IDENTITY)
    private Long id;
    @Setter
    private String username; // 사용자 ID
    @Setter
    private String password;
    @Setter
    private String nickname; // 닉네임
    @Setter
    private String name; // 사용자 이름
    @Setter
    private String age;
    @Setter
    private String email;
    @Setter
    private String phone;
    @Setter
    private String profileImage;
    @Setter
    @Enumerated(EnumType.STRING)
    private UserRole role;

    @Setter
    private String businessNum;
}
```

## 유저 권한
```java
// 유저 권한
public enum UserRole {
    ROLE_INACTIVE, ROLE_USER, ROLE_BUSINESS, ROLE_ADMIN
}

```
사용자 에게 필요한 정보들(id, Id, password 등)과
권한을 부여할 UserRole의 정보입니다.

---

# DTOS
## UserDto
```java
@Getter
@Builder
@ToString
@AllArgsConstructor
public class UserDto {
    private Long id;
    private String username;
    private String password;
    private String nickname;
    private String name;
    private String age;
    private String email;
    private String phone;
    private String profileImage;
    private UserRole role;
    private String businessNum;

    public static UserDto fromEntity(UserEntity entity) {
        return UserDto.builder()
                .username(entity.getUsername())
                .password(entity.getPassword())
                .nickname(entity.getNickname())
                .name(entity.getName())
                .age(entity.getAge())
                .email(entity.getEmail())
                .phone(entity.getPhone())
                .profileImage(entity.getProfileImage())
                .role(entity.getRole())
                .businessNum(entity.getBusinessNum())
                .build();

    }
}
```
Builder 패턴을 사용해 Entity에 저장하도록 합니다

```java
// loginDto
@Data
public class LoginDto {
    private String username;
    private String password;
}
// RegisterDto
@Data
public class RegisterDto {
    private String username;
    private String password;
}
// UpgradeDto
@Data
public class UpgradeDto {
    private String businessNum;
}
// AdminActionDto
@Data
public class AdminActionDto {
    private String username;
    private String password;
}
```
상황에 맞게 Dto를 전송하기 위해 분류한 Dto들입니다.

---

## Controller & Service
```java
// UserController
@RestController
@RequestMapping("users")
@RequiredArgsConstructor
public class UserController {
    private final UserService userService;
    private final JwtTokenUtils jwtTokenUtils;
    private final PasswordEncoder passwordEncoder;

    // 회원가입
    // username과 password만 입력하면 됨
    @PostMapping("/register")
    public UserDto userRegister(
            @RequestBody
            RegisterDto dto
    ) {
        return userService.createUser(dto);
    }

    // 로그인
    // 이걸 하면 Jwt Token 발급됨
    @PostMapping("/login")
    public JwtResponseDto login(
            @RequestBody
            LoginDto dto
    ) {
        return userService.loginUser(dto);
    }

    // 필수 정보 입력
    // postman에서는 username과 password 동봉해야함!
    @PostMapping("/my_profile/fill_info")
    public ResponseEntity<String> updateInfo(
            @RequestBody
            UserDto dto
    ) {
        UserDto updatedUser = userService.activateUser(dto);
        log.info(updatedUser.getNickname());
        log.info(updatedUser.getName());
        log.info(updatedUser.getAge());
        log.info(updatedUser.getEmail());
        log.info(updatedUser.getPhone());

        // 성공 메시지와 업데이트된 정보 포함하여 반환
        String response = String.format(
                "Profile updated successfully!%n" +
                        "Nickname: %s%n" +
                        "Name: %s%n" +
                        "Age: %s%n" +
                        "Email: %s%n" +
                        "Phone: %s",
                dto.getNickname(), dto.getName(), dto.getAge(), dto.getEmail(), dto.getPhone());
        return new ResponseEntity<>(response, HttpStatus.OK);

        // -> public UserDto updateInfo 로 쓴다면
        // Postman에서 dto의 모든 내용을 반환해서 볼 수 있어요!
        // return userService.activateUser(dto);

    }

    // 사업자 번호 추가로 신청하기
    @PostMapping("/my_profile/{username}/fill_business")
    public ResponseEntity<String> promotion(
            @PathVariable("username")
            String username,
            @RequestBody
            UpgradeDto dto
    ) {
        // 일단 UserEntity에 사업자 번호 추가해주기( = 곧 사업자 번호 신청?)
        userService.applyPromotion(username, dto);
        log.info(userService.applyPromotion(username, dto).getBusinessNum());

        // 사실 이러한 방식은 Postman에서 BusinessNum 잘못 입력해도
        // 항상 신청 완료라고 뜨기는 합니다 ( nullable )
        // 다만 딱히 제한 조건에 대해 만들지 않았기에 일단 HttpStatus.Ok...
        String response = String.format(
                "apply confirmed%n" +
                        "BusinessNum : %s", dto.getBusinessNum()
        );
        return new ResponseEntity<>(response, HttpStatus.OK);

        // -> public UserDto applyPromotion
        // return userService.applyPromotion(dto) 로 전체 내용 볼수도 있음
    }

    // 사용자 프로필 이미지 업로드
    // Multipart 공부하고 나중에 구현하도록 하자
    /*
    @PostMapping("/{userId}/profile-image")
    public ResponseEntity<UserDto> uploadProfileImage(
            @PathVariable
            Long userId,
            @RequestParam("image")
            MultipartFile file) {
        UserDto updatedUserDto = userService.updateProfileImage(userId, file);
        return ResponseEntity.ok(updatedUserDto);
    }
    @GetMapping("/my_profile/fill_info_image")
    public UserDto updateProfileImage(
            @RequestBody
            UserDto dto
    ) {
        return userService.uploadImage(dto);
    }
     */


}
```
User들이 최초 회원가입부터, login, 필수정보 입력, 사업자 번호 추가(권한 전환 신청)에 대한 Controller입니다   
처음에는 return service.*** 방식으로 진행하려 했으나
Postman 출력에 Dto 전체가 노출되는 것 보다는 사용자가 input한 정보를 재확인 시켜주는 것이 좋다고 생각되어 response에 담아 반환시켜보았습니다.


```java
// UserService
@Slf4j
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenUtils jwtTokenUtils;

    // 유저 생성 (회원가입 로직)
    public UserDto createUser(RegisterDto registerDto) {
        // 만약에 생성하려는 username이 중복이 있다면
        boolean existsByUsername = userRepository.existsByUsername(registerDto.getUsername());

        if (existsByUsername) {
            throw new ResponseStatusException(HttpStatus.CONFLICT);
        }
        // UserEntity 객체 생성 및 저장
        UserEntity userEntity = UserEntity.builder()
                .username(registerDto.getUsername())
                .password(passwordEncoder.encode(registerDto.getPassword()))
                .role(UserRole.ROLE_INACTIVE) // 기본 권한 설정 (비활성화)
                .build();

        // 저장 후, 저장된 UserEntity를 UserDto로 변환하여 반환
        return UserDto.fromEntity(userRepository.save(userEntity));
    }


    // 유저 로그인 (with Jwt)
    public JwtResponseDto loginUser(LoginDto loginDto) {
        // 사용자 이름으로 사용자 정보 조회
        UserEntity userEntity = userRepository.findByUsername(loginDto.getUsername())
                // 없으면 오류 메세지 출력
                .orElseThrow(() -> new UsernameNotFoundException(
                        "User not found with username: " + loginDto.getUsername()));

        // 조회된 사용자 비밀번호와 입력된 비밀번호 일치 여부 확인
        if (passwordEncoder.matches(loginDto.getPassword(), userEntity.getPassword())) {
            // 비밀번호가 일치하면 JWT 토큰 생성
            String token = jwtTokenUtils.generateToken(userEntity);
            // 생성된 토큰을 JwtResponseDto에 담아 반환
            return new JwtResponseDto(token);
        } else {
            // 비밀번호가 일치하지 않으면 예외 발생
            throw new BadCredentialsException("Invaild username or password supplied");
        }
    }

    // 사용자 필수 정보 업데이트(비활성 -> 활성화로)
    public UserDto activateUser(UserDto userDto) {
        // 먼저 username으로 찾아보기
        Optional<UserEntity> optionalUser
                = userRepository.findByUsername(userDto.getUsername());
        // 없으면 오류 발생
        if (optionalUser.isEmpty())
            throw new UsernameNotFoundException(userDto.getUsername());

                /*
        // id 방식으로 찾는게 아니기에 제거
        UserEntity userEntity = userRepository.findById(userDto.getId())
                // 없으면 오류 메세지 출력
                .orElseThrow(() -> new UsernameNotFoundException(
                        "User not found with id: " + userDto.getId()));
                */
        UserEntity userEntity = optionalUser.get();
        // 있다는 가정 하에 필수 정보 업데이트
        userEntity.setNickname(userDto.getNickname());  // 얘는 닉네임
        userEntity.setName(userDto.getName());          // 얘는 이름
        userEntity.setAge(userDto.getAge());            // 연령대
        userEntity.setEmail(userDto.getEmail());        // 이메일
        userEntity.setPhone(userDto.getPhone());        // 전화번호
                // 이미지는 필수 정보에 해당하지 않음
                // userEntity.setProfileImage(userDto.getProfileImage());

        // 지금은 INACTIVE임
        // 관리자가 아니고, 지금 INACTIVE라면
        if (userEntity.getRole() != UserRole.ROLE_ADMIN
                && userEntity.getRole().equals(UserRole.ROLE_INACTIVE) ){
            userEntity.setRole(UserRole.ROLE_USER);     // 비활성 -> 활성
        }
        // ROLE_USER 사용자가 만약 또 정보를 바꾼다고 해도, Set은 잘 작동될것이고
        // ROLE에 대해서는 어자피 바뀔 일이 없으니 그대로임~
        userRepository.save(userEntity);
        return UserDto.fromEntity(userEntity);
    }

    // 사용자 권한 변경(to 사업자로) 신청
    public UserDto applyPromotion(String username, UpgradeDto dto){
        // 1. 먼저 userRepository에서 username으로 사용자를 찾아보고
        Optional<UserEntity> optionalUser = userRepository.findByUsername(username);
        log.info(optionalUser.toString());
        // 2. 없으면 NOT_FOUND 반환
        if (optionalUser.isEmpty()) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND);
        }
        UserEntity userEntity = optionalUser.get();

        userEntity.setBusinessNum(dto.getBusinessNum());    // 사업자 번호 입력
        userRepository.save(userEntity);                    // 저장소 저장
        return UserDto.fromEntity(userEntity);
    }


    // 사용자 프로필 이미지 업로드
    // Multipart는 나중에 구현하도록 하자
    /*
    public UserDto updateProfileImage(Long userId, MultipartFile file) {
        // 1. 파일을 저장하고 파일 경로를 반환받는 로직 구현 필요
        String imagePath = fileStorageService.storeFile(file);

        // 2. 유저 엔티티를 조회
        UserEntity userEntity = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // 3. 이미지 경로를 엔티티에 설정
        userEntity.setProfileImage(imagePath);

        // 4. 변경 사항 저장
        UserEntity updatedUser = userRepository.save(userEntity);

        // 5. DTO 변환 및 반환
        return UserDto.fromEntity(updatedUser);
    }
     */
}
```
회원가입, 로그인, 사용자 필수 정보 입력, 사용자 권한 변경 신청 로직입니다
<br/>

---



```java
// AdminController
@RestController
@RequestMapping("/admin")
@RequiredArgsConstructor
public class AdminController {
    private final AdminService adminService;

    // 관리자 전용 로그인 (보안+)
    @PostMapping("/login")
    public String adminLogin() {
        return "Not done yet";
    }

    // 관리자가 신청 목록 확인
    @GetMapping("/confirm_list")
    public List<UserEntity> confirmLists() {
        return adminService.getAllApplyUsers();
    }

    // 관리자가 신청 승인 or 신청 거부
    @PostMapping("/confirm_list/{username}/accept")
    public String acceptApply(
            @PathVariable("username")
            String username
    ) {
        adminService.accept();
        return "OK";
    }
    @PostMapping("/confirm_list/{username}/decline")
    public String declineApply(
            @PathVariable("username")
            String username
    ) {
        adminService.decline();
        return "NO";
    }
}
```
admin의 경우, 일반 User의 방식과 겹치면 안된다고 생각되어 Controller와 Service를 분리했습니다


```java
// AdminService
@Service
@RequiredArgsConstructor
// 관리자 기능을 담당
public class AdminService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    // 관리자 로그인


    // 사용자 전환 신청 목록 조회
    public List<UserEntity> getAllApplyUsers() {
        // 사업자 번호 신청한 사용자 목록 조회
        List<UserEntity> applyUsers =
                userRepository.findByRoleAndBusinessNumIsNotNull(UserRole.ROLE_USER);
        if (applyUsers.isEmpty())
            throw new ResponseStatusException(HttpStatus.NOT_FOUND);
        return applyUsers;
    }
    // 사업자 사용자 전환 관련
    // 신청 및 거절
    public void accept() {

    }
    public void decline() {

    }
}
```
(관리자 로그인 서비스와 신청 및 거절 로직은 아직 미구현입니다)

--- 

```java
// 2nd_mission.config.SecurityConfig
@Configuration
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtTokenUtils jwtTokenUtils;

    @Bean
    public SecurityFilterChain securityFilterChain(
            HttpSecurity http
    ) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(
                        auth -> auth
                                // 1. 어떤 경우도 접근 가능함
                                .requestMatchers(
                                        "/home/test")
                                .permitAll()

                                // 2. 인증이 안된 경우만 접근 가능함
                                .requestMatchers(
                                        "/users/login",
                                        "/users/register",
                                        "/admin/login")
                                .anonymous()

                                // 3. 인증이 된 경우만 접근 가능함
                                .requestMatchers(
                                        "/users/my_profile/fill_info",
                                        "/users/my_profile/{username}/fill_business",
                                        "/admin/confirm_list",
                                        "/admin/confirm_list/{username}/accept",
                                        "/admin/confirm_list/{username}/decline"
                                )
                                .authenticated()
                )
                .sessionManagement(sessionManagement ->
                        sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                // 특정 필터 앞에 나만의 필터를 넣는 곳
                .addFilterBefore(
                        new JwtTokenFilter(jwtTokenUtils),
                        AuthorizationFilter.class
                )
        ;
        return http.build();
    }
}
```
WebSecurityConfig 관련 설정입니다